## js模块化

### js为什么没有模块化？

js语言设计的初期只是单纯页面交互，但是随着Ajax的产生和广泛应用，使得表单校验，路由切换等等放到前端实现，代码越来越庞大。

### 为什么会出现模块化？

前端代码越来越庞大，使得难以维护，许多问题暴露出来，如：命名冲突，依赖需要手动维护等等，所以借鉴其他语言：如：C，java来实现模块化的概念。

### 模块化的两种实现方案
#### 解决方案1: 包裹对象
```
var a = {
    name:'xx',
    age:18,
    change:function(){
        
    }
}
```

优点：可以解决命名冲突，但是外部，a对象中的变量暴露给外部，外部可以随意修改内部的属性

#### 解决方案2：函数有作用域（自执行函数）

函数有作用域的概念存在，所以可以实现暴露出函数出来外部不修改内部的数据，外部不能修改内部数据，但是外部可以重写内部数据

```
var a =(function(){
    var name = 'xx';
    var age = 18;
    function change(){
        
    }
    return {
        change:change
    }
})()
```

## 目前js模块化的解决方案
### AMD
- AMD是在**requirejs**的推广中规范出来
- 异步加载依赖，所以会有callback,先将依赖全部加载后，在执行，最后再执行主逻辑
- 依赖前置体现

实现原理：大致上封装了require,define两个函数来管理引入模块，暴露模块

```
1、require([module], callback);
2、define(id, [depends], callback);
```

### CMD
- CMD是在**sea.js**的推广中规范出来
- 异步加载，与AMD不同的，先加载完毕，需要的时候再去执行，先加载后执行
- 依赖就近体现

### CommonJS
- 服务器模块加载规范,比如node;
- 同步加载，文件可以缓存在本地磁盘，加载速度快,对浏览器不够友好；
- 同CMD，先加载，需要的时候在执行；
- 加载的模块，属于值拷贝，与原文件脱离关系

### ES6
- ES6支持关键字import,export来支持引入和暴露模块
- 同AMD规范，先加载，执行完毕，不能条件依赖；
- 加载的模块，属于引用

### CommonJS和CMD
- 都是先加载，需要的时候执行，可以做条件依赖；

### AMD和ES6
- 都是先加载，执行完毕，不能做条件依赖；

### 微信小程序的模块化
- 微信小程序采用CommonJS的语法，但是小程序是运行在微信浏览器里面；
- 运行时，微信小程序会将转成前端模块依赖规范，代码和CMD规范类似；
- 在引用第三方包时，需求强制指定module.exports;
- ？微信小程序为什么需要用CommonJS 规范，运行时转为CMD？



